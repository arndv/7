# 7

![image](https://github.com/arndv/7/assets/125039034/dc10afa0-d737-4b6c-a237-797c5d462c85)

Алгоритъма за двоично търсене работи само и единствено със сортирани елементи, като разделя масива на две части. Ако търсеното число съвпада със средния елемент,тогава алгоритъма връща индекса на средния елемент. 
Ако търсеното число е по-голямо от средния елемент, тогава  търсеното число стои в дясната половина на масива. Тогава разделяме дясната половина отново на две части и сравняваме със средния елемент. 
Ако търсеното число е по-малко от средния елемент тогава търсим в лявата половина на масива, като отново я разделяме на две части и сравняваме със средния елемент.
Алгоритъмът се повтаря докато открием търсения елемент.
Ако x не съвпада с нито един от елементите, връщаме -1.


Дайте пример за това къде можете да срещнете поведението на структурата от данни опашка във вашето ежедневие. И обяснете защо.

Пример : Например опашка от хора, чакащи на каса за билети. Опашката има начало и край. Новодошлите хора застават последни на опашката и изчакват докато постепенно се придвижат към началото. Когато стигнат до самото начало на опашката си купуват билет и напускат опашката. 
Пример 2: Други примери за опашка са документи, чакащи да бъдат отпечатани.
Пример 3: Ескалатор превозващ хора. По този начин опашката изпълнява функцията на буфер.
Защото: Структурата от данни опашка изпълнява условието „първият влязъл първи излиза“ (FIFO: First-In-First-Out). Това означава, че след като е добавен един елемент в края на опашката, той ще може да бъде извлечен (премахнат) единствено след като бъдат премахнати всички елементи преди него в реда, в който са добавени.



Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез метода на мехурчето.


 public static void BubbleSortWithFor(List<int> list)
        {
            for (int j = 0; j <= list.Count - 2; j++)
            {
                for (int i = 0; i <= list.Count - 2; i++)
                {
                    if (list[i] > list[i + 1])
                    {
                        Swap(list, i, i + 1);
                    }
                }
            }
        }
private static void Swap(List<int> list, int index, int min)
        {
            int temp = list[index];
            list[index] = list[min];
            list[min] = temp;
        }
  
 ![image](https://github.com/arndv/7/assets/125039034/364e25a5-2a7b-4f8b-8856-941a2e8f787c)
Каква ще бъде сложността на алгоритъма и обяснете защо?
Ако имаме два вложени цикъла от 1 до N, сложността им е квадратична – O(N2).
  
  
  // 
  var collection = Console.ReadLine().Split().Select(int.Parse).ToList(); 
            for (int index = 0; index < collection.Count; index++)
            {
                int min = index;
                for (int curr = index + 1; curr < collection.Count; curr++)
                {
                    if (collection[curr] < collection[min])
                    {
                        min = curr;
                    }
                }               
                int temp = collection[index]; 
                collection[index] = collection[min];
                collection[min] = temp; 
            }
            Console.WriteLine(string.Join(" ", collection));
                                                           
                                                           
Посочете за алгоритми с каква сложност се отнася следното твърдение:

Алгоритми с [константна, логаритмична и линейна] сложност са толкова бързи, че не можем да усетим забавяне, дори при относително голям размер на входните данни     
                                                           
                                                           
Имате зададени твърдения за два алгоритъма за търсене - двоично търсене и линейно търсене. По зададените твърдения и характеристики трябва да сравните двата алгоритъма и да зададете коя от тях към кой от алгоритмите се отнася:

Стойностите в масива трябва да са сортирани. [Двоично търсене]
Работи във времева сложност O(log n). [Двоично търсене]
Ако ключът е по-малък от средния елемент, тогава ключът може да лежи само в левия подмасив. [Двоично търсене]
Работи във времева сложност O(log(log n)). [Линейно търсене] 
Ако ключът е по-голям от средния елемент, тогава ключът може да лежи само в десния подмасив. [Двоично търсене]
Стойностите в масива не е задължително да са сортирани. [Линейно търсене]
Започва винаги от началото на масива. [Линейно търсене]
Ако ключът съвпада със средния елемент, върнете средното местоположение. [Двоично търсене]
Започва търсенето от средата на масива. [Двоично търсене]


Дефинирайте понятието сложност на алгоритъм, като попълните липсващите думи в текста.

Сложност на алгоритъм е [груба оценка на броя стъпки], които алгоритъмът ще направи в зависимост от [размера на входните данни]. Това е груба оценка, която се интересува от [порядъка на броя стъпки], а не от [точния им брой].

                                                           
                                                           ///
                                                           
                                                           
 var list = Console.ReadLine().Split().Select(int.Parse).ToList();
for (int j = 0; j <= list.Count - 2; j++)//2т
{
    for (int i = 0; i <= list.Count - 2; i++)
    {
        if (list[i] > list[i + 1])//2т
        {
            int temp = list[i];//2т
            list[i] = list[i+1];
            list[i+1] = temp;//2т
        }
    }
}
Console.WriteLine(string.Join(" ", list));

![image](https://github.com/arndv/7/assets/125039034/4b3f88cb-ea76-49c7-a1b4-225eaa1e7b38) 
  
  
  Разработвате ново приложение за оптимизиране на процесите в работата на призводствено предприятие. Трябва да приложите структура от данни, която да работи като „буфер“ срещу надхвърляне на капацитета. Когато сме в рамките на призводствения капацитет, артикулите в буфера трябва да се обработят в реда, в който се добавят. Обяснете коя структура от данни трябва да използвате защо бихте използвали точно нея, за да приложите такъв буфер?
  
Забележка
В опашката, артикулите се обработват в реда, в който са добавени. В частност, артикулите се добавят в края на опашката и се премахват от началото. Това е общоизвестно като first-in, first-out (FIFO) обработване.
![image](https://github.com/arndv/7/assets/125039034/bfdf41e9-cb0f-4223-b145-a00d58dc7651)

 ![image](https://github.com/arndv/7/assets/125039034/b4950a83-d96e-45e3-b6d8-c1b91f29ca83)

  
  
  Дайте пример за това къде можете да срещнете поведението на структурата от данни стек във вашето ежедневие. И обяснете защо.

Забележка
Пример 1 : Работната памет на програмата (стек) - Примитивните типове данни (числа, char, bool) се наричат стойностни типове, защото пазят непосредствено своята стойност в стека за изпълнение на програмата. 

Стекът е често срещана и използвана структура от данни. Стек се използва и вътрешно от C# виртуалната машина за съхранение на променливите в програмата и параметрите при извикване на метод.

Например една променлива, декларирана в метода Main() на програмата се пази в стека докато програмата завърши изпълнението на този метод, т.е. докато не завърши.

Пример 2: Куп с чинии

Пример 3: Куп с книги

Защото: Стекът има поведение последен влязъл пръв излязъл. 
  
  ![image](https://github.com/arndv/7/assets/125039034/8fb67b68-9cc7-4539-a4ec-57f2dcc58640)

  
  ///
  
  var list = Console.ReadLine().Split().Select(int.Parse).ToList();
for (int j = 0; j <= list.Count - 2; j++)//2т
{
    for (int i = 0; i <= list.Count - 2; i++)
    {
        if (list[i] > list[i + 1])
        {
            int temp = list[i];//2т
            list[i] = list[i+1];
            list[i+1] = temp;//2т
        }
    }
}
Console.WriteLine(string.Join(" ", list));


  
Този фрагмент е част от имплементацията на линейната структура от данни стек - премахване на елемент от стек. В кода има грешка! Вашата задача е да анализирате този фрагмент от код и да идентифицирате и поправите правилно грешките в написания програмен код, така че да реши поставената задача. Да допълните кода, ако и когато това е необходимо.
В полето за въвеждане записвате:
1. Вашият анализ на грешката и това как може да бъде поправено. 
2. Редактиран и правилно работещ код.

Забележка
Грешката в кода е, че методът Pop(int index) получава цяло число, което вътре в метода се използва за намиране на елемента в масива и премахването на този елемент. По дефиниция линейната структура стек не работи така. Правилото за работа със стек е "първи влиза - първи излиза". Нямаме право да достъпваме елементите по индекс, освен само и единствено за четене. Когато правим имплементацията за премахване на елемент от стек винаги премахваме последния елемент - в случая трябва да използваме броя на елементите (Count) на мястото на параметъра Index, за да премахнем последния елемент от масива в класа. И самия метод Pop() не трябва да приема параметър.//2т

public T Pop()//2т
        {
            if (this.Count == 0)
            {
                throw new InvalidOperationException("Empty stack");
            }
            this.Count--;//2т
            T element = this.items[this.Count];//2т

            T[] temp = new T[this.items.Length];
            for (int i = 0; i < this.Count; i++)
            {
                temp[i] = this.items[i];
            }

            this.items = temp;
            return element;
        }
              
                                           
                                           
                                           
    ![image](https://github.com/arndv/7/assets/125039034/e73791cc-dd4a-47c9-898f-56240623d2dc)


                                           
Да кажем, че играем на игра, в която трябва да познаете числото. Имате списък с числа от  1 до 20 включително подредени във възходящ ред. Решете задачата, като намерите кое е търсеното число и използвания алгоритъм за търсене на числото. 

Намислям си число и ти предполагаш, че числото е 11. Аз ти казвам, че моето число е по-малко. 

Търсиш в числата между 1 и 10. Предполагаш, че моето число е 5. Аз ти казвам, че моето число е по-малко.

Търсиш в числата между 1 и 4. Предполагаш, че моето число е 2. Аз ти казвам, че моето число е по-голямо.

Позна ли кое е моето число? [Търсеното число е 3]

Кой алгоритъм за търсене използва? [Двоично търсене]
